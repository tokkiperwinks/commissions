<script is:global>
  (() => {
    const restitution = 0.92;
    const linearDamping = 0.999;
    const SAMPLE_WINDOW = 120;

    const bounceSound = new Audio("spammail/pew.mp3");
    const boomSound = new Audio("spammail/bewm.mp3"); // ðŸ’¥ explosion sound

    const shimejis = [];

    // Flash + shake effect
    function screenExplosion() {
      const flash = document.createElement("div");
      flash.className = "screen-flash";
      document.body.appendChild(flash);

      // play boom sound
      boomSound.currentTime = 0;
      boomSound.play().catch(() => {});

      // remove flash after animation
      setTimeout(() => flash.remove(), 300);

      // add shake
      document.body.classList.add("screen-shake");
      setTimeout(() => {
        document.body.classList.remove("screen-shake");
      }, 500);
    }

    function createShimeji(x = 100, y = 100, forcedSprite = null) {
      const buddy = document.createElement("div");
      buddy.className = "shimeji";
      document.body.appendChild(buddy);

      const rand = forcedSprite || (Math.floor(Math.random() * 13) + 1);
      buddy.dataset.sprite = rand;
      buddy.style.background = `url('spammail/spam${rand}.jpg') no-repeat center / contain`;

      let vx = (Math.random() - 0.5) * 400;
      let vy = (Math.random() - 0.5) * 400;
      let dragging = false;
      let dragOffsetX = 0, dragOffsetY = 0;
      const samples = [];

      let angle = 0;
      let spin = 0;

      function rect() { return buddy.getBoundingClientRect(); }
      function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }
      function placeBuddy(nx, ny, rotation = angle) {
        x = nx; y = ny;
        buddy.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${rotation}deg)`;
      }

      buddy.style.position = "fixed";
      buddy.style.top = "0";
      buddy.style.left = "0";
      const size = getComputedStyle(document.documentElement).getPropertyValue("--buddy-size") || "150px";
      buddy.style.width = size;
      buddy.style.height = size;
      buddy.style.zIndex = "2147483647";
      buddy.style.cursor = "grab";

      placeBuddy(x, y);

      let lastTime = performance.now();
      function tick(now) {
        if (!dragging) {
          const dt = Math.min(0.032, (now - lastTime) / 1000);
          x += vx * dt;
          y += vy * dt;

          const speed = Math.sqrt(vx * vx + vy * vy);
          spin += (speed * 0.0005 - spin) * 0.1;
          angle += spin * dt * 180;

          const b = rect();
          const w = window.innerWidth;
          const h = window.innerHeight;

          let hit = false;

          if (x <= 0) { x = 0; vx = Math.abs(vx) * restitution; hit = true; }
          if (x + b.width >= w) { x = w - b.width; vx = -Math.abs(vx) * restitution; hit = true; }
          if (y <= 0) { y = 0; vy = Math.abs(vy) * restitution; hit = true; }
          if (y + b.height >= h) { y = h - b.height; vy = -Math.abs(vy) * restitution; hit = true; }

          if (hit) {
            spin += (Math.random() - 0.5) * 10;
            const s = bounceSound.cloneNode();
            s.volume = 0.1;
            s.playbackRate = 0.8 + Math.random() * 0.8;
            s.play().catch(() => {});
          }

          vx *= linearDamping;
          vy *= linearDamping;
          spin *= 0.99;

          placeBuddy(x, y, angle);
        }
        lastTime = now;
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      buddy.addEventListener("pointerdown", (e) => {
        dragging = true; samples.length = 0;
        buddy.setPointerCapture(e.pointerId);
        const b = rect();
        dragOffsetX = e.clientX - b.left;
        dragOffsetY = e.clientY - b.top;
        vx = vy = spin = 0;
        samples.push({ x: e.clientX, y: e.clientY, t: performance.now() });
      });

      window.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const w = window.innerWidth; const h = window.innerHeight; const b = rect();
        const nx = clamp(e.clientX - dragOffsetX, 0, w - b.width);
        const ny = clamp(e.clientY - dragOffsetY, 0, h - b.height);
        placeBuddy(nx, ny, angle);
        const t = performance.now();
        samples.push({ x: e.clientX, y: e.clientY, t });
        while (samples.length && (t - samples[0].t) > SAMPLE_WINDOW) samples.shift();
      });

      window.addEventListener("pointerup", (e) => {
        if (!dragging) return;
        dragging = false;
        buddy.releasePointerCapture(e.pointerId);
        const n = samples.length;
        if (n >= 2) {
          const a = samples[0];
          const b = samples[n - 1];
          const dt = (b.t - a.t) / 1000;
          if (dt > 0) {
            vx = (b.x - a.x) / dt;
            vy = (b.y - a.y) / dt;
            const MAX = 2000;
            vx = clamp(vx, -MAX, MAX);
            vy = clamp(vy, -MAX, MAX);
            spin = (Math.random() - 0.5) * 20;
          }
        }
        samples.length = 0;
      });

      buddy.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const b = rect();
        createShimeji(x + b.width * 0.2, y + b.height * 0.2, buddy.dataset.sprite);
      });

      buddy._setVelocity = (nx, ny) => {
        vx = nx; vy = ny;
        spin = (Math.random() - 0.5) * 30;
      };

      shimejis.push(buddy);
    }

    document.addEventListener("DOMContentLoaded", () => {
      const tokki = document.querySelector(".tokkigif img");
      if (tokki) {
        tokki.addEventListener("click", () => {
          createShimeji(window.innerWidth / 2, window.innerHeight / 2);
        });
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Shift" && shimejis.length > 0) {
        shimejis.forEach(b => {
          const angle = Math.random() * Math.PI * 2;
          const speed = 1500 + Math.random() * 1500;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          b._setVelocity(vx, vy);
        });
        screenExplosion(); // ðŸ’¥ trigger effects
      }
    });
  })();
</script>

<style>
  .shimeji {
    pointer-events: auto;
  }
</style>
